#Tease Apart Inheritance (梳理并分解继承体系)

某个继承体系同时承担两项责任。
建立两个继承系统，并通过委托关系让一个调用另外一个。

##原因
继承是个好东西，它可以明显的减少子类中的代码量。
但继承体系也很容易被误用，并且这种误用还很容易在开发人员之间蔓延。
今天你为一个小小任务加入一个小小子类，而明天又在继承系统的另一个地方加入另一个子类。
一个星期或者一年之后，你就会发现自己深陷泥潭，而且连一根拐杖都没有。

混乱的继承体系是一个严重的错误，因为它会导致重复的代码，而后者正是程序员生涯的致命毒药，
它会使修改变得困难，因为特定问题的解决被分散到了整个继承系统中。最终，你的代码将非常难以理解。
无法简单的说，这就是“我的继承系统”，它能计算结果。而必须说，“它会计算出结果。。。。”，
这些是用于表现不同形式的子类，每个子类又有一些子类针对不同的国家。

要指出继承系统是否承担了两项不同的责任并不困难：如果继承系统中的某一个特定层级上的所有类，
其子类名称都以相同的形容词开始，很第这个继承系统就很可能承担了两项不同的责任。


##做法
1. 首先识别继承系统所承担的不同责任。然后建立一个二维表格（或者三给或者四维），并以会标轴标识出不同的任务，
我们将重复运用本重构，处理两个或者两个以上的维度。
2. 判断哪一个责任更重要一些，并准备将它留在继承系统之中，准备将别一个责任迁移到另一个继承系统中。
3. 使用Extract Class 从当前的超类中提练出一个新类，用于表示重要性稍低的责任，并在原类中添加实例变量，用于保存新的实例。
3. 对应原继承系统中的每个子类，创建上述新的子类，在原继承系统子类中，将前一步骤所添加的实例变量初始化为新建子类的实例。
4. 针对原继承系统中的每个子类，使用Move Method将原类中我行为搬移到新建子类的实例中。
5. 当原继承系统中的某个子类不再有任何代码时，将它去除。
6. 重复以上步骤，直到原继承体系中的所有子类都被处理过为止。观察新的继承系统中，看看是否有可能对它实施其他重构手法。